<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, minimum-scale=1"/>
    <meta name="generator" content="pdoc 0.7.5"/>
    <title>eclipse.src.DCT API documentation</title>
    <meta name="description" content=""/>
    <link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css'
          rel='stylesheet'>
    <link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css'
          rel='stylesheet'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"
          rel="stylesheet">
    <style>.flex {
        display: flex !important
    }

    body {
        line-height: 1.5em
    }

    #content {
        padding: 20px
    }

    #sidebar {
        padding: 30px;
        overflow: hidden
    }

    .http-server-breadcrumbs {
        font-size: 130%;
        margin: 0 0 15px 0
    }

    #footer {
        font-size: .75em;
        padding: 5px 30px;
        border-top: 1px solid #ddd;
        text-align: right
    }

    #footer p {
        margin: 0 0 0 1em;
        display: inline-block
    }

    #footer p:last-child {
        margin-right: 30px
    }

    h1, h2, h3, h4, h5 {
        font-weight: 300
    }

    h1 {
        font-size: 2.5em;
        line-height: 1.1em
    }

    h2 {
        font-size: 1.75em;
        margin: 1em 0 .50em 0
    }

    h3 {
        font-size: 1.4em;
        margin: 25px 0 10px 0
    }

    h4 {
        margin: 0;
        font-size: 105%
    }

    a {
        color: #058;
        text-decoration: none;
        transition: color .3s ease-in-out
    }

    a:hover {
        color: #e82
    }

    .title code {
        font-weight: bold
    }

    h2[id^="header-"] {
        margin-top: 2em
    }

    .ident {
        color: #900
    }

    pre code {
        background: #f8f8f8;
        font-size: .8em;
        line-height: 1.4em
    }

    code {
        background: #f2f2f1;
        padding: 1px 4px;
        overflow-wrap: break-word
    }

    h1 code {
        background: transparent
    }

    pre {
        background: #f8f8f8;
        border: 0;
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        margin: 1em 0;
        padding: 1ex
    }

    #http-server-module-list {
        display: flex;
        flex-flow: column
    }

    #http-server-module-list div {
        display: flex
    }

    #http-server-module-list dt {
        min-width: 10%
    }

    #http-server-module-list p {
        margin-top: 0
    }

    .toc ul, #index {
        list-style-type: none;
        margin: 0;
        padding: 0
    }

    #index code {
        background: transparent
    }

    #index h3 {
        border-bottom: 1px solid #ddd
    }

    #index ul {
        padding: 0
    }

    #index h4 {
        font-weight: bold
    }

    #index h4 + ul {
        margin-bottom: .6em
    }

    @media (min-width: 200ex) {
        #index .two-column {
            column-count: 2
        }
    }

    @media (min-width: 300ex) {
        #index .two-column {
            column-count: 3
        }
    }

    dl {
        margin-bottom: 2em
    }

    dl dl:last-child {
        margin-bottom: 4em
    }

    dd {
        margin: 0 0 1em 3em
    }

    #header-classes + dl > dd {
        margin-bottom: 3em
    }

    dd dd {
        margin-left: 2em
    }

    dd p {
        margin: 10px 0
    }

    .name {
        background: #eee;
        font-weight: bold;
        font-size: .85em;
        padding: 5px 10px;
        display: inline-block;
        min-width: 40%
    }

    .name:hover {
        background: #e0e0e0
    }

    .name > span:first-child {
        white-space: nowrap
    }

    .name.class > span:nth-child(2) {
        margin-left: .4em
    }

    .inherited {
        color: #999;
        border-left: 5px solid #eee;
        padding-left: 1em
    }

    .inheritance em {
        font-style: normal;
        font-weight: bold
    }

    .desc h2 {
        font-weight: 400;
        font-size: 1.25em
    }

    .desc h3 {
        font-size: 1em
    }

    .desc dt code {
        background: inherit
    }

    .source summary, .git-link-div {
        color: #666;
        text-align: right;
        font-weight: 400;
        font-size: .8em;
        text-transform: uppercase
    }

    .source summary > * {
        white-space: nowrap;
        cursor: pointer
    }

    .git-link {
        color: inherit;
        margin-left: 1em
    }

    .source pre {
        max-height: 500px;
        overflow: auto;
        margin: 0
    }

    .source pre code {
        font-size: 12px;
        overflow: visible
    }

    .hlist {
        list-style: none
    }

    .hlist li {
        display: inline
    }

    .hlist li:after {
        content: ',\2002'
    }

    .hlist li:last-child:after {
        content: none
    }

    .hlist .hlist {
        display: inline;
        padding-left: 1em
    }

    img {
        max-width: 100%
    }

    .admonition {
        padding: .1em .5em;
        margin-bottom: 1em
    }

    .admonition-title {
        font-weight: bold
    }

    .admonition.note, .admonition.info, .admonition.important {
        background: #aef
    }

    .admonition.todo, .admonition.versionadded, .admonition.tip, .admonition.hint {
        background: #dfd
    }

    .admonition.warning, .admonition.versionchanged, .admonition.deprecated {
        background: #fd4
    }

    .admonition.error, .admonition.danger, .admonition.caution {
        background: lightpink
    }</style>
    <style media="screen and (min-width: 700px)">@media screen and (min-width: 700px) {
        #sidebar {
            width: 30%
        }

        #content {
            width: 70%;
            max-width: 100ch;
            padding: 3em 4em;
            border-left: 1px solid #ddd
        }

        pre code {
            font-size: 1em
        }

        .item .name {
            font-size: 1em
        }

        main {
            display: flex;
            flex-direction: row-reverse;
            justify-content: flex-end
        }

        .toc ul ul, #index ul {
            padding-left: 1.5em
        }

        .toc > ul > li {
            margin-top: .5em
        }
    }</style>
    <style media="print">@media print {
        #sidebar h1 {
            page-break-before: always
        }

        .source {
            display: none
        }
    }

    @media print {
        * {
            background: transparent !important;
            color: #000 !important;
            box-shadow: none !important;
            text-shadow: none !important
        }

        a[href]:after {
            content: " (" attr(href) ")";
            font-size: 90%
        }

        a[href][title]:after {
            content: none
        }

        abbr[title]:after {
            content: " (" attr(title) ")"
        }

        .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
            content: ""
        }

        pre, blockquote {
            border: 1px solid #999;
            page-break-inside: avoid
        }

        thead {
            display: table-header-group
        }

        tr, img {
            page-break-inside: avoid
        }

        img {
            max-width: 100% !important
        }

        @page {
            margin: 0.5cm
        }

        p, h2, h3 {
            orphans: 3;
            widows: 3
        }

        h1, h2, h3, h4, h5, h6 {
            page-break-after: avoid
        }
    }</style>
</head>
<body>
<main>
    <article id="content">
        <header>
            <h1 class="title">Module <code>eclipse.src.DCT</code></h1>
        </header>
        <section id="section-intro">
            <details class="source">
                <summary>
                    <span>Expand source code</span>
                </summary>
                <pre><code class="python">import itertools
import random
import warnings
from os.path import abspath
import cv2
import numpy as np
from bitstring import BitArray

from eclipse.common import settings, utils


class DCT:
    def __init__(self, cover_image_path, cipher_msg):
        self.__cover_image_path_ = abspath(cover_image_path)
        self.__cover_image_ = utils.get_image(cover_image_path)
        self.verify_and_apply_padding()
        self.__height_, self.__width_ = self.__cover_image_.shape[:2]
        self.__cipher_text_ = cipher_msg
        self.__bin_message_ = BitArray(bytes=cipher_msg).bin
        self.__message_length_ = len(self.__bin_message_)
        self.verify_ciphertext_size()

        self.__block_list_ = None

    # VERIFICATION METHODS ============================================================

    def verify_ciphertext_size(self):
        &#34;&#34;&#34;
        Verifies that the length of the message to hide
        is shorter than the maximum available space in the image.
        Warning is raised if the message length is &gt; (10% of the available capacity).
        &#34;&#34;&#34;
        area = self.__height_ * self.__width_
        if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
            raise ValueError(
                &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
        tot_blocks = self.__height_ * self.__width_ // 64
        if self.__message_length_ &gt; tot_blocks:
            raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
        if self.__message_length_ &gt; tot_blocks / 10:
            purcentage_of_occupied_storage = round(
                self.__message_length_ / tot_blocks * 100)
            warning = f&#34;Message occupies ≈ &#34; \
                      f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                      &#34;A smaller text is preferred (&lt; 10%)&#34;
            warnings.warn(warning)

    def verify_and_apply_padding(self):
        &#34;&#34;&#34;
        Checks and eventually resizes image applying a padding
        if any side length is not a multiple of 8.
        The original image is eventually replaced by the padded
        (with sides multiple of 8) image.
        &#34;&#34;&#34;
        original_height, original_width = self.__cover_image_.shape[:2]
        if original_height % 8 != 0 or original_width % 8 != 0:
            self.__cover_image_ = cv2.resize(self.__cover_image_, (
                original_width + (8 - original_width % 8),
                original_height + (8 - original_height % 8)))
            cv2.imwrite(self.__cover_image_path_, self.__cover_image_)

    # BREAK/RECOMPOSE METHODS =========================================================

    @staticmethod
    def break_image_into_blocks(img: np.ndarray) -&gt; list:
        &#34;&#34;&#34;
        Breaks the coverimage into a sequence of 8x8 blocks,
        from top left to bottom right.
        :param img: Coverimage to break into n 8x8 blocks.
        :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
        &#34;&#34;&#34;
        if not isinstance(img, np.ndarray):
            raise TypeError(&#34;Cannot break a non np.array image&#34;)
        height, width = len(img), len(img[0])
        return [img[j: j + 8, i: i + 8] for (j, i) in
                itertools.product(range(0, height, 8),
                                  range(0, width, 8))]

    def recompose_image(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of method &#39;breakImageIntoBlocks&#39;:
        Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
        :return: Re-composed image [NUMPY NDARRAY]
        &#34;&#34;&#34;
        if len(self.__block_list_) == 0:
            raise ValueError
        full_image = np.zeros(shape=(self.__height_, self.__width_),
                              dtype=np.uint8)  # Builds empty image
        for i in range(len(self.__block_list_)):  # Filling image
            curr_col_index = 8 * (i % (self.__width_ // 8))
            curr_line_index = 8 * (i // (self.__width_ // 8))
            full_image[
            curr_line_index:curr_line_index + 8,
            curr_col_index:curr_col_index + 8
            ] = self.__block_list_[i]
        return full_image

    # QUANTIZATION METHODS ============================================================

    @staticmethod
    def quantize_block(block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Centers values of a block, runs it through DCT func. and quantizes it.
        :param block: 8x8 block of pixels [NUMPY NDARRAY]
        :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        img_block = np.subtract(block, 128)
        dct_block = cv2.dct(img_block.astype(np.float64))
        dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
        dct_block[0][0] = np.round(dct_block[0][0])
        return dct_block

    @staticmethod
    def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of &#34;getQuantizedBlock&#34;.
        :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
        :return: Original 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        dct_block = quantized_block
        dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
        unquantized_block = cv2.idct(dct_block)
        return np.add(unquantized_block, 128)

    # LENGTH EMBED/EXTRACT METHODS ====================================================

    def length_to_binary(self) -&gt; list:
        &#34;&#34;&#34;
        Gives binary form of the length and adds a separator to that representation.
        :return: Binary representation of the length + separator to embed [LIST OF STR]
        &#34;&#34;&#34;
        if self.__message_length_ % 8 != 0:
            raise ValueError(&#34;Message length is not multiple of 8&#34;)
        msg_length = int(
            self.__message_length_ / 8
        )  # Decimal representation of the length
        n_required_bits = msg_length.bit_length()
        tmp = f&#34;0{n_required_bits}b&#34;
        binary_length = format(msg_length, tmp)
        return list(binary_length) + utils.string_to_binary(
            settings.LENGTH_MSG_SEPARATOR)

    def embed_msg_length(self):
        &#34;&#34;&#34;
        Inserts the length of the message and end symbol (in binary form)
        at the beginning of the picture.
        At the end, &#39;__block_list_&#39; will be the image with embedded length,
        as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                    NUMPY NDARRAY]
        &#34;&#34;&#34;
        mess_len_to_binary = self.length_to_binary()
        for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
            quantized_block = self.quantize_block(
                self.__block_list_[block_index])
            if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
                quantized_block[0][0] -= 1
            elif quantized_block[0][0] % 2 == 0 and int(
                    length_bit_to_embed) == 1:
                quantized_block[0][0] += 1
            self.__block_list_[
                block_index] = self.get_original_block_from_quantized(
                quantized_block)

    @staticmethod
    def extract_msg_length(img: np.ndarray) -&gt; int:
        &#34;&#34;&#34;
        Extracts the length (in bits) of the message embedded in the stegoimage.
        :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
        :return: Length of the message to extract from the stegoimage [INT]
        &#34;&#34;&#34;
        block_index = 0
        separator_found = False
        decoded_length = &#34;&#34;
        while (not separator_found) and (
                block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
            block = utils.extract_block_from_image(img, block_index)
            unquantized_block = DCT.quantize_block(block)
            decoded_length += str(int(unquantized_block[0][0] % 2))
            if len(decoded_length) &gt; 8:
                current_letter = str(chr(int(decoded_length[-8:], 2)))
                if current_letter == settings.LENGTH_MSG_SEPARATOR:
                    separator_found = True
            block_index += 1
        return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8

    # ENCODE/DECODE MESSAGE METHODS ===================================================

    @staticmethod
    def get_random_blocks_from_msg_length(seed: int,
                                          binary_msg_length: int,
                                          height: int,
                                          width: int) -&gt; list:
        &#34;&#34;&#34;
        Generates a random sequence of indices, (interpreted as the position
        of bits of the message to embed/extract in/from the cover/stegoimage.
        :param seed: Chosen seed [INT]
        :param binary_msg_length: length of the message to extract
                                  from the stegoimage [INT]
        :param height: Height of the cover/stegoimage [INT]
        :param width: Width of the cover/stegoimage [INT]
        :return: List of indexes [LIST OF INT]
        &#34;&#34;&#34;
        tot_blocks = height * width // 64
        random.seed(seed)
        chosen_blocks_indices = random.sample(
            range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
            binary_msg_length)
        return chosen_blocks_indices

    def encode_r(self, output_path: str, seed: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Embed message into cover image:
        1 - Embed the length.
        2 - Embed the message equally distributing bits according
            to a random sequence of indices
            and inserting them in the LSB of DCT quantized blocks.
        :param output_path: Path of stegoimage that will be generated
                            after message insertion [STR]
        :param seed: Chosen seed [INT]
        :return: Stegoimage [NUMPY NDARRAY]
        &#34;&#34;&#34;
        y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
        mess_len = len(self.__cipher_text_)
        positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                               self.__height_,
                                                               self.__width_)
        self.__block_list_ = self.break_image_into_blocks(cb)
        self.embed_msg_length()
        for message_index, block_index in enumerate(positions_lst):
            block = self.__block_list_[block_index]
            dct_block = self.quantize_block(block)
            coeff = int(dct_block[0][0])

            message_bit = self.__bin_message_[message_index]
            if (coeff % 2) == 1 and int(message_bit) == 0:
                dct_block[0][0] -= 1
            elif (coeff % 2) == 0 and int(message_bit) == 1:
                dct_block[0][0] += 1

            self.__block_list_[block_index] = self.get_original_block_from_quantized(
                dct_block
            )
        modified_cb = self.recompose_image()
        final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                      cr,
                                                                      modified_cb)
        cv2.imwrite(output_path, final_img_standard_format)
        return final_img_standard_format

    @staticmethod
    def decode_r(setego_img_path: str, seed: int) -&gt; bytes:
        &#34;&#34;&#34;
        Extract a message from a stegoimage:
        1 - Extract the length of the message.
        2 - Generate the random sequence of indices.
        3 - Extract the message.
        :param stego_img_path: Path of stegoimage
                               from which to extract the message [STR]
        :param seed: Chosen seed [INT]
        :return: Message hidden in the stegoimage [BYTE STR]
        &#34;&#34;&#34;
        original_stego_img = utils.get_image(setego_img_path)
        _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
        height, width = original_stego_img.shape[:2]
        msg_length = DCT.extract_msg_length(cb)
        positions_lst = DCT.get_random_blocks_from_msg_length(
            seed, msg_length, height, width)
        decoded_msg = &#34;0b&#34;
        block_list = DCT.break_image_into_blocks(cb)
        for message_index, block_index in enumerate(positions_lst):
            block_index = positions_lst[message_index]
            block = block_list[block_index]
            dct_block = DCT.quantize_block(block)
            coeff = int(dct_block[0][0])
            decoded_msg += str(
                coeff % 2)  # Adding to the message the currently read bit
        return BitArray(decoded_msg).bytes


if __name__ == &#34;__main__&#34;:
    from eclipse.src.EncryptionUtils import encrypt_message, decrypt_message

    message = &#34;HELLO THIS IS A LONG MESSAGE&#34;
    encrypted = encrypt_message(message, &#34;password&#34;)
    d = DCT(&#34;eclipse/data/test_image.jpg&#34;, encrypted)
    encoded = d.encode_r(&#34;eclipse/data/ycrcb_output.png&#34;, 20)
    decoded = DCT.decode_r(&#34;eclipse/data/ycrcb_output.png&#34;, 20)
    decoded_message = decrypt_message(decoded, &#34;password&#34;)
    print(decoded_message)</code></pre>
            </details>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
            <h2 class="section-title" id="header-classes">Classes</h2>
            <dl>
                <dt id="eclipse.src.DCT.DCT"><code class="flex name class">
                    <span>class <span class="ident">DCT</span></span>
                    <span>(</span><span>cover_image_path, cipher_msg)</span>
                </code></dt>
                <dd>
                    <section class="desc"></section>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">class DCT:
    def __init__(self, cover_image_path, cipher_msg):
        self.__cover_image_path_ = abspath(cover_image_path)
        self.__cover_image_ = utils.get_image(cover_image_path)
        self.verify_and_apply_padding()
        self.__height_, self.__width_ = self.__cover_image_.shape[:2]
        self.__cipher_text_ = cipher_msg
        self.__bin_message_ = BitArray(bytes=cipher_msg).bin
        self.__message_length_ = len(self.__bin_message_)
        self.verify_ciphertext_size()

        self.__block_list_ = None

    # VERIFICATION METHODS ============================================================

    def verify_ciphertext_size(self):
        &#34;&#34;&#34;
        Verifies that the length of the message to hide
        is shorter than the maximum available space in the image.
        Warning is raised if the message length is &gt; (10% of the available capacity).
        &#34;&#34;&#34;
        area = self.__height_ * self.__width_
        if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
            raise ValueError(
                &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
        tot_blocks = self.__height_ * self.__width_ // 64
        if self.__message_length_ &gt; tot_blocks:
            raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
        if self.__message_length_ &gt; tot_blocks / 10:
            purcentage_of_occupied_storage = round(
                self.__message_length_ / tot_blocks * 100)
            warning = f&#34;Message occupies ≈ &#34; \
                      f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                      &#34;A smaller text is preferred (&lt; 10%)&#34;
            warnings.warn(warning)

    def verify_and_apply_padding(self):
        &#34;&#34;&#34;
        Checks and eventually resizes image applying a padding
        if any side length is not a multiple of 8.
        The original image is eventually replaced by the padded
        (with sides multiple of 8) image.
        &#34;&#34;&#34;
        original_height, original_width = self.__cover_image_.shape[:2]
        if original_height % 8 != 0 or original_width % 8 != 0:
            self.__cover_image_ = cv2.resize(self.__cover_image_, (
                original_width + (8 - original_width % 8),
                original_height + (8 - original_height % 8)))
            cv2.imwrite(self.__cover_image_path_, self.__cover_image_)

    # BREAK/RECOMPOSE METHODS =========================================================

    @staticmethod
    def break_image_into_blocks(img: np.ndarray) -&gt; list:
        &#34;&#34;&#34;
        Breaks the coverimage into a sequence of 8x8 blocks,
        from top left to bottom right.
        :param img: Coverimage to break into n 8x8 blocks.
        :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
        &#34;&#34;&#34;
        if not isinstance(img, np.ndarray):
            raise TypeError(&#34;Cannot break a non np.array image&#34;)
        height, width = len(img), len(img[0])
        return [img[j: j + 8, i: i + 8] for (j, i) in
                itertools.product(range(0, height, 8),
                                  range(0, width, 8))]

    def recompose_image(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of method &#39;breakImageIntoBlocks&#39;:
        Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
        :return: Re-composed image [NUMPY NDARRAY]
        &#34;&#34;&#34;
        if len(self.__block_list_) == 0:
            raise ValueError
        full_image = np.zeros(shape=(self.__height_, self.__width_),
                              dtype=np.uint8)  # Builds empty image
        for i in range(len(self.__block_list_)):  # Filling image
            curr_col_index = 8 * (i % (self.__width_ // 8))
            curr_line_index = 8 * (i // (self.__width_ // 8))
            full_image[
            curr_line_index:curr_line_index + 8,
            curr_col_index:curr_col_index + 8
            ] = self.__block_list_[i]
        return full_image

    # QUANTIZATION METHODS ============================================================

    @staticmethod
    def quantize_block(block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Centers values of a block, runs it through DCT func. and quantizes it.
        :param block: 8x8 block of pixels [NUMPY NDARRAY]
        :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        img_block = np.subtract(block, 128)
        dct_block = cv2.dct(img_block.astype(np.float64))
        dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
        dct_block[0][0] = np.round(dct_block[0][0])
        return dct_block

    @staticmethod
    def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of &#34;getQuantizedBlock&#34;.
        :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
        :return: Original 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        dct_block = quantized_block
        dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
        unquantized_block = cv2.idct(dct_block)
        return np.add(unquantized_block, 128)

    # LENGTH EMBED/EXTRACT METHODS ====================================================

    def length_to_binary(self) -&gt; list:
        &#34;&#34;&#34;
        Gives binary form of the length and adds a separator to that representation.
        :return: Binary representation of the length + separator to embed [LIST OF STR]
        &#34;&#34;&#34;
        if self.__message_length_ % 8 != 0:
            raise ValueError(&#34;Message length is not multiple of 8&#34;)
        msg_length = int(
            self.__message_length_ / 8
        )  # Decimal representation of the length
        n_required_bits = msg_length.bit_length()
        tmp = f&#34;0{n_required_bits}b&#34;
        binary_length = format(msg_length, tmp)
        return list(binary_length) + utils.string_to_binary(
            settings.LENGTH_MSG_SEPARATOR)

    def embed_msg_length(self):
        &#34;&#34;&#34;
        Inserts the length of the message and end symbol (in binary form)
        at the beginning of the picture.
        At the end, &#39;__block_list_&#39; will be the image with embedded length,
        as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                    NUMPY NDARRAY]
        &#34;&#34;&#34;
        mess_len_to_binary = self.length_to_binary()
        for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
            quantized_block = self.quantize_block(
                self.__block_list_[block_index])
            if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
                quantized_block[0][0] -= 1
            elif quantized_block[0][0] % 2 == 0 and int(
                    length_bit_to_embed) == 1:
                quantized_block[0][0] += 1
            self.__block_list_[
                block_index] = self.get_original_block_from_quantized(
                quantized_block)

    @staticmethod
    def extract_msg_length(img: np.ndarray) -&gt; int:
        &#34;&#34;&#34;
        Extracts the length (in bits) of the message embedded in the stegoimage.
        :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
        :return: Length of the message to extract from the stegoimage [INT]
        &#34;&#34;&#34;
        block_index = 0
        separator_found = False
        decoded_length = &#34;&#34;
        while (not separator_found) and (
                block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
            block = utils.extract_block_from_image(img, block_index)
            unquantized_block = DCT.quantize_block(block)
            decoded_length += str(int(unquantized_block[0][0] % 2))
            if len(decoded_length) &gt; 8:
                current_letter = str(chr(int(decoded_length[-8:], 2)))
                if current_letter == settings.LENGTH_MSG_SEPARATOR:
                    separator_found = True
            block_index += 1
        return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8

    # ENCODE/DECODE MESSAGE METHODS ===================================================

    @staticmethod
    def get_random_blocks_from_msg_length(seed: int,
                                          binary_msg_length: int,
                                          height: int,
                                          width: int) -&gt; list:
        &#34;&#34;&#34;
        Generates a random sequence of indices, (interpreted as the position
        of bits of the message to embed/extract in/from the cover/stegoimage.
        :param seed: Chosen seed [INT]
        :param binary_msg_length: length of the message to extract
                                  from the stegoimage [INT]
        :param height: Height of the cover/stegoimage [INT]
        :param width: Width of the cover/stegoimage [INT]
        :return: List of indexes [LIST OF INT]
        &#34;&#34;&#34;
        tot_blocks = height * width // 64
        random.seed(seed)
        chosen_blocks_indices = random.sample(
            range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
            binary_msg_length)
        return chosen_blocks_indices

    def encode_r(self, output_path: str, seed: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Embed message into cover image:
        1 - Embed the length.
        2 - Embed the message equally distributing bits according
            to a random sequence of indices
            and inserting them in the LSB of DCT quantized blocks.
        :param output_path: Path of stegoimage that will be generated
                            after message insertion [STR]
        :param seed: Chosen seed [INT]
        :return: Stegoimage [NUMPY NDARRAY]
        &#34;&#34;&#34;
        y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
        mess_len = len(self.__cipher_text_)
        positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                               self.__height_,
                                                               self.__width_)
        self.__block_list_ = self.break_image_into_blocks(cb)
        self.embed_msg_length()
        for message_index, block_index in enumerate(positions_lst):
            block = self.__block_list_[block_index]
            dct_block = self.quantize_block(block)
            coeff = int(dct_block[0][0])

            message_bit = self.__bin_message_[message_index]
            if (coeff % 2) == 1 and int(message_bit) == 0:
                dct_block[0][0] -= 1
            elif (coeff % 2) == 0 and int(message_bit) == 1:
                dct_block[0][0] += 1

            self.__block_list_[block_index] = self.get_original_block_from_quantized(
                dct_block
            )
        modified_cb = self.recompose_image()
        final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                      cr,
                                                                      modified_cb)
        cv2.imwrite(output_path, final_img_standard_format)
        return final_img_standard_format

    @staticmethod
    def decode_r(setego_img_path: str, seed: int) -&gt; bytes:
        &#34;&#34;&#34;
        Extract a message from a stegoimage:
        1 - Extract the length of the message.
        2 - Generate the random sequence of indices.
        3 - Extract the message.
        :param stego_img_path: Path of stegoimage
                               from which to extract the message [STR]
        :param seed: Chosen seed [INT]
        :return: Message hidden in the stegoimage [BYTE STR]
        &#34;&#34;&#34;
        original_stego_img = utils.get_image(setego_img_path)
        _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
        height, width = original_stego_img.shape[:2]
        msg_length = DCT.extract_msg_length(cb)
        positions_lst = DCT.get_random_blocks_from_msg_length(
            seed, msg_length, height, width)
        decoded_msg = &#34;0b&#34;
        block_list = DCT.break_image_into_blocks(cb)
        for message_index, block_index in enumerate(positions_lst):
            block_index = positions_lst[message_index]
            block = block_list[block_index]
            dct_block = DCT.quantize_block(block)
            coeff = int(dct_block[0][0])
            decoded_msg += str(
                coeff % 2)  # Adding to the message the currently read bit
        return BitArray(decoded_msg).bytes</code></pre>
                    </details>
                    <h3>Static methods</h3>
                    <dl>
                        <dt id="eclipse.src.DCT.DCT.break_image_into_blocks"><code
                                class="name flex">
                            <span>def <span class="ident">break_image_into_blocks</span></span>(<span>img)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Breaks the coverimage into a
                                sequence of 8x8 blocks,
                                from top left to bottom right.
                                :param img: Coverimage to break into n 8x8 blocks.
                                :return: List of blocks of pixels [LIST OF NUMPY
                                NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def break_image_into_blocks(img: np.ndarray) -&gt; list:
    &#34;&#34;&#34;
    Breaks the coverimage into a sequence of 8x8 blocks,
    from top left to bottom right.
    :param img: Coverimage to break into n 8x8 blocks.
    :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
    &#34;&#34;&#34;
    if not isinstance(img, np.ndarray):
        raise TypeError(&#34;Cannot break a non np.array image&#34;)
    height, width = len(img), len(img[0])
    return [img[j: j + 8, i: i + 8] for (j, i) in
            itertools.product(range(0, height, 8),
                              range(0, width, 8))]</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.decode_r"><code class="name flex">
                            <span>def <span class="ident">decode_r</span></span>(<span>setego_img_path, seed)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Extract a message from a
                                stegoimage:
                                1 - Extract the length of the message.
                                2 - Generate the random sequence of indices.
                                3 - Extract the message.
                                :param stego_img_path: Path of stegoimage
                                from which to extract the message [STR]
                                :param seed: Chosen seed [INT]
                                :return: Message hidden in the stegoimage [BYTE STR]</p>
                            </section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def decode_r(setego_img_path: str, seed: int) -&gt; bytes:
    &#34;&#34;&#34;
    Extract a message from a stegoimage:
    1 - Extract the length of the message.
    2 - Generate the random sequence of indices.
    3 - Extract the message.
    :param stego_img_path: Path of stegoimage
                           from which to extract the message [STR]
    :param seed: Chosen seed [INT]
    :return: Message hidden in the stegoimage [BYTE STR]
    &#34;&#34;&#34;
    original_stego_img = utils.get_image(setego_img_path)
    _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
    height, width = original_stego_img.shape[:2]
    msg_length = DCT.extract_msg_length(cb)
    positions_lst = DCT.get_random_blocks_from_msg_length(
        seed, msg_length, height, width)
    decoded_msg = &#34;0b&#34;
    block_list = DCT.break_image_into_blocks(cb)
    for message_index, block_index in enumerate(positions_lst):
        block_index = positions_lst[message_index]
        block = block_list[block_index]
        dct_block = DCT.quantize_block(block)
        coeff = int(dct_block[0][0])
        decoded_msg += str(
            coeff % 2)  # Adding to the message the currently read bit
    return BitArray(decoded_msg).bytes</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.extract_msg_length"><code
                                class="name flex">
                            <span>def <span
                                    class="ident">extract_msg_length</span></span>(<span>img)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Extracts the length (in bits) of
                                the message embedded in the stegoimage.
                                :param img: Stegoimage from which to extract the message
                                [NUMPY NDARRAY]
                                :return: Length of the message to extract from the
                                stegoimage [INT]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def extract_msg_length(img: np.ndarray) -&gt; int:
    &#34;&#34;&#34;
    Extracts the length (in bits) of the message embedded in the stegoimage.
    :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
    :return: Length of the message to extract from the stegoimage [INT]
    &#34;&#34;&#34;
    block_index = 0
    separator_found = False
    decoded_length = &#34;&#34;
    while (not separator_found) and (
            block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
        block = utils.extract_block_from_image(img, block_index)
        unquantized_block = DCT.quantize_block(block)
        decoded_length += str(int(unquantized_block[0][0] % 2))
        if len(decoded_length) &gt; 8:
            current_letter = str(chr(int(decoded_length[-8:], 2)))
            if current_letter == settings.LENGTH_MSG_SEPARATOR:
                separator_found = True
        block_index += 1
    return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.get_original_block_from_quantized">
                            <code class="name flex">
                                <span>def <span class="ident">get_original_block_from_quantized</span></span>(<span>quantized_block)</span>
                            </code></dt>
                        <dd>
                            <section class="desc"><p>Inverse of "getQuantizedBlock".
                                :param quantized_block: Quantized 8x8 block of pixels
                                [NUMPY NDARRAY]
                                :return: Original 8x8 block of pixels [NUMPY
                                NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inverse of &#34;getQuantizedBlock&#34;.
    :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
    :return: Original 8x8 block of pixels [NUMPY NDARRAY]
    &#34;&#34;&#34;
    dct_block = quantized_block
    dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
    unquantized_block = cv2.idct(dct_block)
    return np.add(unquantized_block, 128)</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.get_random_blocks_from_msg_length">
                            <code class="name flex">
                                <span>def <span class="ident">get_random_blocks_from_msg_length</span></span>(<span>seed, binary_msg_length, height, width)</span>
                            </code></dt>
                        <dd>
                            <section class="desc"><p>Generates a random sequence of
                                indices, (interpreted as the position
                                of bits of the message to embed/extract in/from the
                                cover/stegoimage.
                                :param seed: Chosen seed [INT]
                                :param binary_msg_length: length of the message to
                                extract
                                from the stegoimage [INT]
                                :param height: Height of the cover/stegoimage [INT]
                                :param width: Width of the cover/stegoimage [INT]
                                :return: List of indexes [LIST OF INT]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def get_random_blocks_from_msg_length(seed: int,
                                      binary_msg_length: int,
                                      height: int,
                                      width: int) -&gt; list:
    &#34;&#34;&#34;
    Generates a random sequence of indices, (interpreted as the position
    of bits of the message to embed/extract in/from the cover/stegoimage.
    :param seed: Chosen seed [INT]
    :param binary_msg_length: length of the message to extract
                              from the stegoimage [INT]
    :param height: Height of the cover/stegoimage [INT]
    :param width: Width of the cover/stegoimage [INT]
    :return: List of indexes [LIST OF INT]
    &#34;&#34;&#34;
    tot_blocks = height * width // 64
    random.seed(seed)
    chosen_blocks_indices = random.sample(
        range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
        binary_msg_length)
    return chosen_blocks_indices</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.quantize_block"><code
                                class="name flex">
                            <span>def <span
                                    class="ident">quantize_block</span></span>(<span>block)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Centers values of a block, runs it
                                through DCT func. and quantizes it.
                                :param block: 8x8 block of pixels [NUMPY NDARRAY]
                                :return:Quantized 8x8 block of pixels [NUMPY
                                NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">@staticmethod
def quantize_block(block: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Centers values of a block, runs it through DCT func. and quantizes it.
    :param block: 8x8 block of pixels [NUMPY NDARRAY]
    :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
    &#34;&#34;&#34;
    img_block = np.subtract(block, 128)
    dct_block = cv2.dct(img_block.astype(np.float64))
    dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
    dct_block[0][0] = np.round(dct_block[0][0])
    return dct_block</code></pre>
                            </details>
                        </dd>
                    </dl>
                    <h3>Methods</h3>
                    <dl>
                        <dt id="eclipse.src.DCT.DCT.embed_msg_length"><code
                                class="name flex">
                            <span>def <span class="ident">embed_msg_length</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Inserts the length of the message
                                and end symbol (in binary form)
                                at the beginning of the picture.
                                At the end, '__block_list_' will be the image with
                                embedded length,
                                as list of blocks of pixels (from top left to bottom
                                right) [LIST OF
                                NUMPY NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def embed_msg_length(self):
    &#34;&#34;&#34;
    Inserts the length of the message and end symbol (in binary form)
    at the beginning of the picture.
    At the end, &#39;__block_list_&#39; will be the image with embedded length,
    as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                NUMPY NDARRAY]
    &#34;&#34;&#34;
    mess_len_to_binary = self.length_to_binary()
    for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
        quantized_block = self.quantize_block(
            self.__block_list_[block_index])
        if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
            quantized_block[0][0] -= 1
        elif quantized_block[0][0] % 2 == 0 and int(
                length_bit_to_embed) == 1:
            quantized_block[0][0] += 1
        self.__block_list_[
            block_index] = self.get_original_block_from_quantized(
            quantized_block)</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.encode_r"><code class="name flex">
                            <span>def <span class="ident">encode_r</span></span>(<span>self, output_path, seed)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Embed message into cover image:
                                1 - Embed the length.
                                2 - Embed the message equally distributing bits
                                according
                                to a random sequence of indices
                                and inserting them in the LSB of DCT quantized blocks.
                                :param output_path: Path of stegoimage that will be
                                generated
                                after message insertion [STR]
                                :param seed: Chosen seed [INT]
                                :return: Stegoimage [NUMPY NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def encode_r(self, output_path: str, seed: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Embed message into cover image:
    1 - Embed the length.
    2 - Embed the message equally distributing bits according
        to a random sequence of indices
        and inserting them in the LSB of DCT quantized blocks.
    :param output_path: Path of stegoimage that will be generated
                        after message insertion [STR]
    :param seed: Chosen seed [INT]
    :return: Stegoimage [NUMPY NDARRAY]
    &#34;&#34;&#34;
    y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
    mess_len = len(self.__cipher_text_)
    positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                           self.__height_,
                                                           self.__width_)
    self.__block_list_ = self.break_image_into_blocks(cb)
    self.embed_msg_length()
    for message_index, block_index in enumerate(positions_lst):
        block = self.__block_list_[block_index]
        dct_block = self.quantize_block(block)
        coeff = int(dct_block[0][0])

        message_bit = self.__bin_message_[message_index]
        if (coeff % 2) == 1 and int(message_bit) == 0:
            dct_block[0][0] -= 1
        elif (coeff % 2) == 0 and int(message_bit) == 1:
            dct_block[0][0] += 1

        self.__block_list_[block_index] = self.get_original_block_from_quantized(
            dct_block
        )
    modified_cb = self.recompose_image()
    final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                  cr,
                                                                  modified_cb)
    cv2.imwrite(output_path, final_img_standard_format)
    return final_img_standard_format</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.length_to_binary"><code
                                class="name flex">
                            <span>def <span class="ident">length_to_binary</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Gives binary form of the length and
                                adds a separator to that representation.
                                :return: Binary representation of the length + separator
                                to embed [LIST OF STR]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def length_to_binary(self) -&gt; list:
    &#34;&#34;&#34;
    Gives binary form of the length and adds a separator to that representation.
    :return: Binary representation of the length + separator to embed [LIST OF STR]
    &#34;&#34;&#34;
    if self.__message_length_ % 8 != 0:
        raise ValueError(&#34;Message length is not multiple of 8&#34;)
    msg_length = int(
        self.__message_length_ / 8
    )  # Decimal representation of the length
    n_required_bits = msg_length.bit_length()
    tmp = f&#34;0{n_required_bits}b&#34;
    binary_length = format(msg_length, tmp)
    return list(binary_length) + utils.string_to_binary(
        settings.LENGTH_MSG_SEPARATOR)</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.recompose_image"><code
                                class="name flex">
                            <span>def <span class="ident">recompose_image</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Inverse of method
                                'breakImageIntoBlocks':
                                Recompose the image from the sorted list of blocks of
                                pixels '__block_list_'.
                                :return: Re-composed image [NUMPY NDARRAY]</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def recompose_image(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inverse of method &#39;breakImageIntoBlocks&#39;:
    Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
    :return: Re-composed image [NUMPY NDARRAY]
    &#34;&#34;&#34;
    if len(self.__block_list_) == 0:
        raise ValueError
    full_image = np.zeros(shape=(self.__height_, self.__width_),
                          dtype=np.uint8)  # Builds empty image
    for i in range(len(self.__block_list_)):  # Filling image
        curr_col_index = 8 * (i % (self.__width_ // 8))
        curr_line_index = 8 * (i // (self.__width_ // 8))
        full_image[
        curr_line_index:curr_line_index + 8,
        curr_col_index:curr_col_index + 8
        ] = self.__block_list_[i]
    return full_image</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.verify_and_apply_padding"><code
                                class="name flex">
                            <span>def <span
                                    class="ident">verify_and_apply_padding</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Checks and eventually resizes image
                                applying a padding
                                if any side length is not a multiple of 8.
                                The original image is eventually replaced by the padded
                                (with sides multiple of 8) image.</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def verify_and_apply_padding(self):
    &#34;&#34;&#34;
    Checks and eventually resizes image applying a padding
    if any side length is not a multiple of 8.
    The original image is eventually replaced by the padded
    (with sides multiple of 8) image.
    &#34;&#34;&#34;
    original_height, original_width = self.__cover_image_.shape[:2]
    if original_height % 8 != 0 or original_width % 8 != 0:
        self.__cover_image_ = cv2.resize(self.__cover_image_, (
            original_width + (8 - original_width % 8),
            original_height + (8 - original_height % 8)))
        cv2.imwrite(self.__cover_image_path_, self.__cover_image_)</code></pre>
                            </details>
                        </dd>
                        <dt id="eclipse.src.DCT.DCT.verify_ciphertext_size"><code
                                class="name flex">
                            <span>def <span class="ident">verify_ciphertext_size</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <section class="desc"><p>Verifies that the length of the
                                message to hide
                                is shorter than the maximum available space in the
                                image.
                                Warning is raised if the message length is &gt; (10% of
                                the available capacity).</p></section>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def verify_ciphertext_size(self):
    &#34;&#34;&#34;
    Verifies that the length of the message to hide
    is shorter than the maximum available space in the image.
    Warning is raised if the message length is &gt; (10% of the available capacity).
    &#34;&#34;&#34;
    area = self.__height_ * self.__width_
    if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
        raise ValueError(
            &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
    tot_blocks = self.__height_ * self.__width_ // 64
    if self.__message_length_ &gt; tot_blocks:
        raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
    if self.__message_length_ &gt; tot_blocks / 10:
        purcentage_of_occupied_storage = round(
            self.__message_length_ / tot_blocks * 100)
        warning = f&#34;Message occupies ≈ &#34; \
                  f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                  &#34;A smaller text is preferred (&lt; 10%)&#34;
        warnings.warn(warning)</code></pre>
                            </details>
                        </dd>
                    </dl>
                </dd>
            </dl>
        </section>
    </article>
    <nav id="sidebar">
        <h1>Index</h1>
        <div class="toc">
            <ul></ul>
        </div>
        <ul id="index">
            <li><h3>Super-module</h3>
                <ul>
                    <li><code><a title="eclipse.src"
                                 href="index.html">eclipse.src</a></code></li>
                </ul>
            </li>
            <li><h3><a href="#header-classes">Classes</a></h3>
                <ul>
                    <li>
                        <h4><code><a title="eclipse.src.DCT.DCT"
                                     href="#eclipse.src.DCT.DCT">DCT</a></code></h4>
                        <ul class="">
                            <li><code><a
                                    title="eclipse.src.DCT.DCT.break_image_into_blocks"
                                    href="#eclipse.src.DCT.DCT.break_image_into_blocks">break_image_into_blocks</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.decode_r"
                                         href="#eclipse.src.DCT.DCT.decode_r">decode_r</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.embed_msg_length"
                                         href="#eclipse.src.DCT.DCT.embed_msg_length">embed_msg_length</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.encode_r"
                                         href="#eclipse.src.DCT.DCT.encode_r">encode_r</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.extract_msg_length"
                                         href="#eclipse.src.DCT.DCT.extract_msg_length">extract_msg_length</a></code>
                            </li>
                            <li><code><a
                                    title="eclipse.src.DCT.DCT.get_original_block_from_quantized"
                                    href="#eclipse.src.DCT.DCT.get_original_block_from_quantized">get_original_block_from_quantized</a></code>
                            </li>
                            <li><code><a
                                    title="eclipse.src.DCT.DCT.get_random_blocks_from_msg_length"
                                    href="#eclipse.src.DCT.DCT.get_random_blocks_from_msg_length">get_random_blocks_from_msg_length</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.length_to_binary"
                                         href="#eclipse.src.DCT.DCT.length_to_binary">length_to_binary</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.quantize_block"
                                         href="#eclipse.src.DCT.DCT.quantize_block">quantize_block</a></code>
                            </li>
                            <li><code><a title="eclipse.src.DCT.DCT.recompose_image"
                                         href="#eclipse.src.DCT.DCT.recompose_image">recompose_image</a></code>
                            </li>
                            <li><code><a
                                    title="eclipse.src.DCT.DCT.verify_and_apply_padding"
                                    href="#eclipse.src.DCT.DCT.verify_and_apply_padding">verify_and_apply_padding</a></code>
                            </li>
                            <li><code><a
                                    title="eclipse.src.DCT.DCT.verify_ciphertext_size"
                                    href="#eclipse.src.DCT.DCT.verify_ciphertext_size">verify_ciphertext_size</a></code>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>
</main>
<footer id="footer">
    <p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.
    </p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>